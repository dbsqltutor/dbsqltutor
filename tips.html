<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Tips & Insights – SQL Tutoring</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="description" content="Short, practical tips and insights on SQL, databases, and data modeling.">
  <meta name="robots" content="index, follow">

  <link rel="stylesheet" href="styles.css">

  <style>
    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      margin: 0;
      padding: 0;
      line-height: 1.6;
      color: #222;
      background-color: #f7f7f9;
    }
    header {
      background: #f97316;
      color: #fff;
      padding: 2.5rem 1.5rem;
      text-align: center;
    }
    header h1 {
      margin: 0 0 0.5rem;
      font-size: 2rem;
    }
    .container {
      max-width: 960px;
      margin: 0 auto;
      padding: 2rem 1.5rem;
      background: #fff;
    }
    h2 {
      margin-top: 0;
      font-size: 1.6rem;
      color: #111827;
      border-bottom: 2px solid #e5e7eb;
      padding-bottom: 0.5rem;
    }
    h3 {
      font-size: 1.3rem;
      margin-top: 2rem;
      color: #111827;
    }
    .nav {
      background: #111827;
      padding: 0.75rem 1rem;
      text-align: center;
    }
    .nav a {
      color: #fff;
      margin: 0 1rem;
      text-decoration: none;
      font-weight: 500;
    }
    .nav a:hover {
      text-decoration: underline;
    }
    .nav .active {
      font-weight: 700;
      text-decoration: underline;
    }
    footer {
      text-align: center;
      padding: 1.5rem;
      font-size: 0.9rem;
      color: #6b7280;
    }
    ul {
      margin-left: 1.2rem;
    }
  </style>
</head>

<body>

<nav class="nav">
  <a href="index.html">Home</a>
  <a href="about.html">About</a>
  <a href="pricing.html">Pricing</a>
  <a href="tips.html" class="active">Tips & Insights</a>
  <a href="contact.html">Contact</a>
</nav>

<header>
  <h1>Tips & Insights</h1>
  <p>Short, practical lessons on SQL, databases, and data modeling</p>
</header>

<main class="container" style="display: flex; gap: 2rem;">

  <!-- SIDEBAR -->
  <aside style="
      width: 240px;
      flex-shrink: 0;
      background: #f3f4f6;
      border: 1px solid #e5e7eb;
      padding: 1.5rem;
      border-radius: 6px;
      height: fit-content;
      position: sticky;
      top: 1.5rem;
    ">

    <h3 style="margin-top: 0; font-size: 1.2rem; color: #111827;">Browse Tips</h3>

    <h4 style="margin-bottom: 0.5rem; color: #374151;">SQL Tips</h4>
    <ul style="margin-top: 0.3rem;">
      <li><a href="#sql-tip-1">Why SELECT * Hurts Performance</a></li>
      <li><a href="#sql-tip-2">Hidden Effects of ORDER BY on Views</a></li>
      <li><a href="#sql-tip-3">JOIN vs WHERE -- What Goes Where and Why</a></li>
    </ul>

    <h4 style="margin-bottom: 0.5rem; margin-top: 1.5rem; color: #374151;">Database Tips</h4>
    <ul style="margin-top: 0.3rem;">
      <li><a href="#db-tip-1">Choosing the Right Data Types</a></li>
      <li><a href="#db-tip-2">How Optimizer Uses Indexes</a></li>
    </ul>

    <h4 style="margin-bottom: 0.5rem; margin-top: 1.5rem; color: #374151;">Data Modeling Tips</h4>
    <ul style="margin-top: 0.3rem;">
      <li><a href="#dm-tip-1">Conceptual, Logical, and Physical Models</a></li>
    </ul>

  </aside>

  <!-- MAIN CONTENT -->
  <div style="flex: 1;">

    <section>
      <h2>Welcome</h2>
      <p>
        Learning SQL and understanding how databases really work becomes much easier when concepts are explained clearly
        and in the right order. This section is where I share short, practical insights on SQL, databases, and data
        modeling — the same principles I use when tutoring students one-on-one.
      </p>

      <p>
        Each tip focuses on one idea at a time. Some are beginner-friendly fundamentals, others explore intermediate
        techniques, and some dive into advanced reasoning used in real-world systems. The goal is always the same:
        to help you build clarity, structure, and confidence in how you think about data.
      </p>

      <p>Here are a few example topics you’ll find here:</p>

      <ul>
        <li>Why <code>SELECT *</code> hurts performance more than you think</li>
        <li>INNER vs LEFT JOIN — when each one makes sense</li>
        <li>How to translate real-world rules into tables</li>
        <li>Why normalization reduces anomalies in your data</li>
        <li>Choosing between natural and surrogate keys</li>
      </ul>

      <p>
        New tips are added regularly. Check back often as you continue building your SQL, database, and data modeling skills.
      </p>
    </section>

    <!-- SQL TIP #1 -->
    <!-- SQL TIP #1 -->
    <!-- SQL TIP #1 -->
    <section id="sql-tip-1">
      <h2>SQL Tip #1: Why SELECT * Hurts Performance More Than You Think</h2>

      <p>Ever wonder why a query feels slow even when the table isn’t that big? A common culprit is <code>SELECT *</code>. It looks harmless, but it quietly creates several performance problems.</p>

      <h3>What’s really happening when you use SELECT *:</h3>
      <ul>
        <li>You return every column from every table in the query — even ones you don’t need.</li>
        <li>More data means more I/O, more memory use, and more work for the database engine.</li>
        <li>Wide datatypes (JSON, XML, VARCHAR(MAX), BLOB) make the slowdown even worse.</li>
        <li>The optimizer may be unable to use covering indexes, forcing extra lookups.</li>
      </ul>

      <h3>A simple rule of thumb:</h3>
      <p><strong>Only select the columns you actually need.</strong></p>

      <h3>Quick example:</h3>
      <p><strong>Instead of:</strong><br>
      <code>SELECT * FROM Orders</code></p>

      <p><strong>Try:</strong><br>
      <code>SELECT OrderID, OrderDate, TotalAmount FROM Orders</code></p>

      <div style="margin-top: 2rem; border-top: 1px solid #e5e7eb; padding-top: 1rem;">
        <a href="#db-tip-1">Next Tip ?</a>
      </div>
    </section>

    <!-- SQL TIP #2 -->
    <!-- SQL TIP #2 -->
    <!-- SQL TIP #2 -->
    <section id="sql-tip-2">
    <h2>SQL Tip #2: The Hidden Effects of Using <code>ORDER BY</code> in Views</h2>

    <p>Ever added an <code>ORDER BY</code> inside a view and expected the results to always come out sorted?</p> 
    <p>It feels intuitive… but most DBMS don’t treat views that way. Relying on <code>ORDER BY</code> inside a view can lead to inconsistent results and assumptions that quietly break as your data or execution plans change.</p>

    <h3>The real issue</h3>
    <p>A view is a logical query, not a stored, pre-sorted dataset. Nothing inside a view is physically materialized, so there’s no ordering to preserve.</p>
    <p>When you query a view, the DBMS expands its definition like a subquery and then optimizes the entire statement as one unit. During this rewrite, the optimizer may:</p>

    <ul>
        <li>remove the <code>ORDER BY</code></li>
        <li>reorder joins</li>
        <li>push filters down</li>
        <li>merge the view into the outer query</li>
    </ul>

    <p>If the <code>ORDER BY</code> inside the view doesn’t affect the logical result, the optimizer is free to ignore it. The logical result is the set of rows returned — not the order in which they appear. Since the <code>ORDER BY</code> inside the view has no effect on which rows are included, it doesn’t influence the logical outcome. As a result, the optimizer can safely drop it during query processing.</p>

    <h3>So why does it look like <code>ORDER BY</code> in a view works?</h3>
    <p>Because sometimes the optimizer chooses a plan that happens to return rows in the order you expect — usually due to:</p>

    <ul>
        <li>an index that matches the view’s <code>ORDER BY</code></li>
        <li>a clustered key aligned with the sort</li>
        <li>a plan that doesn’t need to reorder rows</li>
        <li>small data volumes that don’t trigger alternative strategies</li>
    </ul>

    <p>This creates the illusion that the view is enforcing the sort. But the moment the optimizer chooses a different plan, the order changes. It wasn’t guaranteed — it was coincidence.</p>

    <h3>A simple rule of thumb</h3>
    <p>Treat a view like a subquery — use it to shape the data, and let the outer query handle the sorting.</p>

    <h3>Quick example</h3>
    <p>You create a view with an <code>ORDER BY</code>, then run:</p>

    <pre><code>SELECT * FROM vwStudents;
</code></pre>

    <p>Even if the view sorts by <code>Name</code>, this query is <strong>not guaranteed</strong> to return sorted results.</p>

    <p>To ensure sorted output from a view, code your logic as:</p>

    <pre><code>SELECT * 
FROM (SELECT * FROM vwStudents) AS x
ORDER BY x.Name;
</code></pre>

    <p>This works — but not because the view had an <code>ORDER BY</code>. It works because the <strong>outer query</strong> controls the final ordering.</p>

    <h3>Final thought</h3>
    <p>If your results seem to “randomly” change order when querying a view, the root cause is often a misplaced assumption that the view’s <code>ORDER BY</code> is being enforced. Keep sorting in the outer query where it belongs.</p>
</section>

    <!-- SQL TIP #3 -->
    <!-- SQL TIP #3 -->
    <!-- SQL TIP #3 -->
<section id="sql-tip-3">
  <h2>SQL Tip #3: JOIN vs WHERE — What Goes Where, and Why It Matters</h2>

  <p>SQL won’t stop you from misusing <code>ON</code> and <code>WHERE</code> — it’ll just give you unpredictable results when you least expect them.</p>
  <p>When writing joins, it’s easy to mix up what belongs in the <code>ON</code> clause and what belongs in the <code>WHERE</code> clause.</p>
  <p>A simple rule keeps everything clean:</p>

  <h3>ON vs WHERE — The Core Idea</h3>
  <ul>
    <li><strong>(join) ON:</strong> defines how tables relate (PK/FK)</li>
    <li><strong>WHERE:</strong> defines which rows survive after the join</li>
  </ul>

  <p>Think of it this way:</p>
  <ul>
    <li><strong>ON = relationship logic</strong></li>
    <li><strong>WHERE = filtering logic</strong></li>
  </ul>

  <p>This mental model prevents subtle bugs — especially with outer joins.</p>

  <h3>INNER JOIN: Filter in ON vs Filter in WHERE</h3>
  <p>For INNER JOINs, these two patterns behave the same:</p>

  <p><strong>Filter inside the JOIN</strong></p>
  <pre><code>JOIN Orders o ON c.CustomerID = o.CustomerID
AND c.City = o.City</code></pre>

  <p><strong>Filter inside the WHERE</strong></p>
  <pre><code>JOIN Orders o ON c.CustomerID = o.CustomerID
WHERE c.City = o.City</code></pre>

  <p>
    Both return the same rows (NULLs aside) because INNER JOIN only keeps rows that satisfy both conditions.
    This is why INNER JOIN isn’t ideal for showing the ON vs WHERE difference.
  </p>

  <h3>LEFT/RIGHT/FULL JOIN: Where the Difference Actually Matters</h3>
  <p>Outer joins preserve unmatched rows — and that’s where ON vs WHERE diverge.</p>

  <h3>LEFT JOIN + AND (Filtering affects row matching)</h3>
  <pre><code>LEFT JOIN Orders o ON c.CustomerID = o.CustomerID
AND c.City = o.City</code></pre>

  <ul>
    <li>The ON clause defines the row-matching rule</li>
    <li>If the city comparison fails (including NULL), the row simply doesn’t match</li>
    <li>But because it’s a LEFT JOIN, the left row still returns with NULLs on the right</li>
  </ul>

  <p>This preserves the core LEFT JOIN behavior: return all rows from the left table.</p>

  <h3>LEFT JOIN + WHERE (Filtering affects row survival)</h3>
  <pre><code>LEFT JOIN Orders o ON c.CustomerID = o.CustomerID
WHERE c.City = o.City</code></pre>

  <ul>
    <li>The LEFT JOIN first returns matched + unmatched rows</li>
    <li>The WHERE clause filters afterward</li>
    <li>Unmatched rows fail the comparison and are removed</li>
  </ul>

  <p>This effectively turns the LEFT JOIN into an INNER JOIN.</p>

  <h3>Closing Thought</h3>
  <p>
    Use <code>ON</code> to describe how tables connect.<br>
    Use <code>WHERE</code> to filter the final result set.
  </p>

  <p>
    For INNER JOINs, both approaches look the same.<br>
    For LEFT, RIGHT, and FULL OUTER JOINs, they behave very differently — and understanding that distinction is essential for predictable SQL.
  </p>

  <h3>One Last Best Practice</h3>
  <p><strong>Avoid using WHERE to join tables.</strong><br>
     Always join using <code>JOIN … ON</code> — it keeps your intent clear and your outer joins behaving as expected.
  </p>

  <div style="margin-top: 2rem; border-top: 1px solid #e5e7eb; padding-top: 1rem;">
    <a href="#sql-tip-1">Back to Top ?</a>
  </div>
</section>

    <!-- DATABASE TIP #1 -->
    <!-- DATABASE TIP #1 -->
    <!-- DATABASE TIP #1 -->
    <section id="db-tip-1">
      <h2>Database Tip #1: Why Choosing the Right Data Types Matters</h2>

      <p>This is a classic example of why datatypes matter more than most people think.<br>
         Oversized or inconsistent data types often cause unnecessary storage and slower reads.</p>

      <h3>What goes wrong when using the wrong data type:</h3>
      <ul>
        <li><strong>Poor integrity:</strong> Storing dates as VARCHAR allows inconsistent formats like 1/10/2025, 2025/10/1, or January 10, 2025.</li>
        <li><strong>Invalid values:</strong> A column meant for ages defined as VARCHAR could accept values like <em>‘twenty’</em>, <em>‘20’</em> or <em>‘999’</em>.</li>
        <li><strong>Slower queries:</strong> Comparing '123' (stored as text) to a number forces the database to convert types, possibly blocking index use.</li>
        <li><strong>Inefficient sorting:</strong> Sorting '10', '2', '100' as strings gives incorrect order compared to numeric sorting.</li>
        <li><strong>Wasted storage:</strong> Using <code>CHAR(50)</code> for a 2-digit code inflates row size and reduces page density; use VARCHAR instead.</li>
        <li><strong>Weaker validation:</strong> A VARCHAR column meant for prices can’t prevent entries like <em>‘free’</em> or <em>‘ten dollars’</em>.</li>
      </ul>

      <h3>When using the wrong data length:</h3>
      <p>For example, storing a person’s age as <code>NUMBER(2)</code> is sufficient.  However, specifying a length of 5 instead can lead to:</p>

      <ul>
        <li>Extra storage for a wider numeric definition.</li>
        <li>Larger index entries, which can slow index scans and lookups.</li>
        <li>Reduced block/page density because fewer rows fit into each data block.</li>
        <li>More work for the engine to handle higher precision numeric type than needed.</li>
        <li>Increased memory and cache usage when moving and comparing the wider value.</li>
      </ul>

      <h3>Two simple rules of thumb:</h3>
      <ol>
        <li><strong>Match the data type to the nature of the data.</strong></li>
        For example:
          CHAR/VARCHAR for alphanumeric text.<br>
          INT/NUMBER/DECIMAL, etc. for numeric values.<br>
          DATE/DATETIME for dates and timestamps.
        <li><strong>Specify a maximum length that makes sense.</strong></li>
          For example, using NUMBER(10) for a person’s age is excessive.<br>
          Age will never exceed three digits (and realistically, two).
      </ol>

      <div style="margin-top: 2rem; border-top: 1px solid #e5e7eb; padding-top: 1rem;">
        <a href="#sql-tip-1">? Previous Tip</a>
      </div>
    </section>

<!-- DATABASE TIP #2 -->
<!-- DATABASE TIP #2 -->
<!-- DATABASE TIP #2 -->
<section id="db-tip-2">

  <h2>Database Tip #2 — How the Optimizer Uses Indexes</h2>

  <p>
    Understanding why a database optimizer chooses an index seek in some cases and a full scan in others
    is one of the most important mental models in query tuning. Yet it’s also one of the most misunderstood.
    Many people assume seeks are always “good” and scans are always “bad,” but the optimizer is far more
    strategic than that.
  </p>

  <p>
    At the heart of every access-path decision is a single idea:
    <strong>how much of the table the query is expected to touch</strong>.
    Once you understand that, the optimizer’s behavior becomes predictable — and tuning becomes easier.
  </p>

  <p>
    Here, I break down the seek-vs-scan decision flow in a clear, visual way so you can see exactly
    how the optimizer thinks.
  </p>

  <p>
    When a query includes a filter, the optimizer must choose the most efficient way to retrieve the required rows.
    That choice almost always comes down to two access paths:
  </p>

  <ul>
    <li>Use an index seek to jump directly to matching rows, or</li>
    <li>Perform a table or index scan to read pages sequentially.</li>
  </ul>

  <p>
    The optimizer makes this decision using a simple but powerful concept:
    <strong>selectivity — how many rows the filter is expected to return</strong>.
  </p>

  <p>
    To understand how this works, here’s a clear, step-by-step decision flow that mirrors the optimizer’s logic.
  </p>

  <h3>Optimizer Decision Flow: Seek or Scan?</h3>
  <img src="HowOptimizerUsesIndexes.png" alt="How Optimizer Uses Indexes diagram">

  <p>
    <strong>Note:</strong>
    This diagram shows the optimizer’s behavior when evaluating a single filter condition.
    With multiple predicates, the optimizer considers each indexed column, their combined selectivity,
    and whether composite indexes exist.
  </p>

  <h3>Understanding Selectivity</h3>

  <p>Selectivity determines whether the index is helpful:</p>

  <ul>
    <li><strong>High selectivity:</strong> the filter returns a small percentage of the table</li>
    <li><strong>Low selectivity:</strong> the filter returns a large percentage of the table</li>
  </ul>

  <p>
    And importantly… if the query has no filter at all, the optimizer must read the entire table —
    which always results in a scan, regardless of the table’s size.
  </p>

  <ul>
    <li>On small tables, this is fast.</li>
    <li>On large tables, it can be expensive — but still cheaper than using an index when all rows are needed.</li>
  </ul>

  <h3>Why Scans Aren’t Always “Bad”</h3>

  <p>
    A scan simply means: <strong>“Read all data pages sequentially in storage order.”</strong>
  </p>

  <p>
    Sequential I/O is extremely efficient as the DBMS reads large amounts of data with minimal overhead,
    which is why scans can outperform seeks when many rows are needed.
  </p>

  <p>
    And here’s the key nuance: whether a scan is “fast” or “slow” is relative to the size of the table.
  </p>

  <ul>
    <li>On small tables, scanning every page is often faster than seeking into an index.</li>
    <li>
      On large tables, a scan can be expensive — but still cheaper than performing thousands or millions
      of random lookups when many rows are needed.
    </li>
  </ul>

  <p>
    <strong>Indexes help only when they allow the optimizer to avoid reading non-qualifying data.</strong>
    If most of the table must be read anyway, the index provides no benefit.
  </p>

  <h3>Takeaway</h3>

  <p>
    <strong>Indexes improve performance by reducing the amount of data the DBMS must read.</strong>
  </p>

  <p>
    If the filter is highly selective, a seek is efficient.
    If the filter returns many rows — or there’s no filter at all — a scan becomes the cheapest option.
  </p>

</section>

<!-- DATA MODELING TIP #1 -->
<!-- DATA MODELING TIP #1 -->
<!-- DATA MODELING TIP #1 -->
<section id="dm-tip-1">
  <h2>Data Modeling Tip #1: Conceptual, Logical, and Physical Models</h2>

  <p>
    A solid database doesn't begin with tables — it begins with understanding the business. 
    Data modeling gives you a structured path from idea to schema, moving through three layers:
  </p>

  <ul>
    <li>Conceptual</li>
    <li>Logical</li>
    <li>Physical</li>
  </ul>

  <p>
    Each layer answers a different question — what the business needs, how the data fits together, 
    and how it will be implemented; adding more detail and precision at each step.
  </p>

  <p>
    Data modeling isn't just documentation — it's how you prevent rework, miscommunication, and 
    inconsistent data structures. When these layers are skipped or blurred, teams end up with 
    mismatched assumptions, duplicated data, and systems that are hard to maintain.
  </p>

  <h3>Conceptual Model — The Business View</h3>

  <p>This is the highest-level model. It captures what the business cares about, without technical detail.</p>
  <p>
    A conceptual model is like a city map that shows neighborhoods but not street names — it gives 
    orientation without overwhelming detail.
  </p>

  <h4>Focus:</h4>
  <ul>
    <li>Major entities (Customer, Order, Product)</li>
    <li>High-level relationships (Customers place Orders)</li>
    <li>No attributes, no keys, no data types</li>
  </ul>

  <h4>Purpose:</h4>
  <p>Align business stakeholders on the core “things” the system must track.</p>  
  <p>Once the business concepts are clear, we can proceed to the logica lmodel to add structure...</p>

  <h3>Logical Model — The Structural Blueprint</h3>

  <p>
    This is where the model becomes detailed and structured, but still independent of any specific 
    database platform.
  </p>

  <h4>Focus:</h4>
  <ul>
    <li>Entities and their attributes</li>
    <li>Primary keys and candidate keys</li>
    <li>Relationship cardinalities (1:1, 1-M, M:N)</li>
    <li>Normalization and business rules</li>
  </ul>

  <p>
    Normalization ensures each fact is stored once, in the right place, reducing redundancy and 
    improving data integrity. The logical model is where these rules take shape.
  </p>

  <h4>Purpose:</h4>
  <p>
    Define how the data fits together logically.
  </p>

  <p>Where entities and attributes fit:</p>
  <ul>
    <li>Entities remain entities</li>
    <li>Attributes are now fully defined</li>
    <li>Still no tables or columns — this is platform-agnostic</li>
    <li>Keys and relationships are introduced to define identity and structure</li>
  </ul>

  <p>
    At the logical stage, nothing is tied to Oracle, SQL Server, PostgreSQL, MySQL, or any specific DBMS.  
    It’s the “what” and “how,” not the “where.”
  </p>
  <p>With the logical rules defined, we can now translate the design into a real database in the physicala model...</p>


  <h3>Physical Model — The Database Implementation</h3>

  <p>
    This is the model that becomes the actual database schema.
  </p>

  <h4>Focus:</h4>
  <ul>
    <li>Tables and columns</li>
    <li>Data types</li>
    <li>Indexes, constraints, foreign keys</li>
    <li>Naming conventions (e.g., <code>customer_id</code>, <code>order_id</code>)</li>
    <li>Platform-specific considerations (SQL Server, PostgreSQL, MySQL, etc.)</li>
  </ul>

  <h4>Purpose:</h4>
  <p>
    Translate the logical design into a working, optimized database.
  </p>

  <p>Where entities and attributes fit:</p>
  <ul>
    <li>Entities become tables</li>
    <li>Attributes become columns</li>
    <li>Relationships become foreign keys</li>
    <li>Keys become PK/FK constraints and indexes</li>
  </ul>

  <p>This is the stage where the abstract becomes concrete.</p>  
  <p>
    The physical model introduces performance considerations: indexing strategies, storage formats, 
    partitioning, and naming conventions that support long-term maintainability.
  </p>

  <h3>Example Across All Three Layers</h3>

  <h4>Conceptual:</h4>
  <img src="ConceptualModel.png" alt="Conceptual Data Model diagram">
  <p>Entities and relationships only.</p>

  <h4>Logical:</h4>
  <img src="LogicalModel.png" alt="Logical Data Model diagram">
  <p>Entities, attributes, relationships, keys.</p>

  <h4>Physical:</h4>
  <img src="PhysicalModel.png" alt="Physical Data Model diagram">
  <p>Tables, columns, relationships, keys, datatypes.</p>

  <h3>Final Thoughts</h3>
  <p>
    Conceptual models define the things.<br>
    Logical models define the details.<br>
    Physical models define the implementation.<br>
  </p> 
  <p>
    Entities become tables.<br>
    Attributes become columns.
  </p>

  <p>
    Get that flow right, and your data model becomes clear, scalable, and easy to maintain.
  </p>

  <h3>Quick Disclaimer</h3>
  <p>
    It's common to hear people refer to entities as “tables” and attributes as “columns” even when discussing 
    conceptual or logical models. It’s everyday shorthand — just be aware of which layer you’re actually working in.
  </p>

  <div style="margin-top: 2rem; border-top: 1px solid #e5e7eb; padding-top: 1rem;">
    <a href="#sql-tip-1">Back to Top ?</a>
  </div>
</section>

  </div>
</main>
  
<footer>
  &copy; <span id="year"></span> db.sql.tutor – Database & SQL Tutoring
</footer>

<script>
  document.getElementById('year').textContent = new Date().getFullYear();
</script>

</body>
</html>

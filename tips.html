<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Tips & Insights – SQL Tutoring</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="description" content="Short, practical tips and insights on SQL, databases, and data modeling.">
  <meta name="robots" content="index, follow">

  <link rel="stylesheet" href="styles.css">

  <style>
    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      margin: 0;
      padding: 0;
      line-height: 1.6;
      color: #222;
      background-color: #f7f7f9;
    }
    header {
      background: #f97316;
      color: #fff;
      padding: 2.5rem 1.5rem;
      text-align: center;
    }
    header h1 {
      margin: 0 0 0.5rem;
      font-size: 2rem;
    }
    .container {
      max-width: 960px;
      margin: 0 auto;
      padding: 2rem 1.5rem;
      background: #fff;
    }
    h2 {
      margin-top: 0;
      font-size: 1.6rem;
      color: #111827;
      border-bottom: 2px solid #e5e7eb;
      padding-bottom: 0.5rem;
    }
    h3 {
      font-size: 1.3rem;
      margin-top: 2rem;
      color: #111827;
    }
    .nav {
      background: #111827;
      padding: 0.75rem 1rem;
      text-align: center;
    }
    .nav a {
      color: #fff;
      margin: 0 1rem;
      text-decoration: none;
      font-weight: 500;
    }
    .nav a:hover {
      text-decoration: underline;
    }
    .nav .active {
      font-weight: 700;
      text-decoration: underline;
    }
    footer {
      text-align: center;
      padding: 1.5rem;
      font-size: 0.9rem;
      color: #6b7280;
    }
    ul {
      margin-left: 1.2rem;
    }
  </style>
</head>

<body>

<nav class="nav">
  <a href="index.html">Home</a>
  <a href="about.html">About</a>
  <a href="pricing.html">Pricing</a>
  <a href="tips.html" class="active">Tips & Insights</a>
  <a href="contact.html">Contact</a>
</nav>

<header>
  <h1>Tips & Insights</h1>
  <p>Short, practical lessons on SQL, databases, and data modeling</p>
</header>

<main class="container" style="display: flex; gap: 2rem;">

  <!-- SIDEBAR -->
  <aside style="
      width: 240px;
      flex-shrink: 0;
      background: #f3f4f6;
      border: 1px solid #e5e7eb;
      padding: 1.5rem;
      border-radius: 6px;
      height: fit-content;
      position: sticky;
      top: 1.5rem;
    ">

    <h3 style="margin-top: 0; font-size: 1.2rem; color: #111827;">Browse Tips</h3>

    <h4 style="margin-bottom: 0.5rem; color: #374151;">SQL Tips</h4>
    <ul style="margin-top: 0.3rem;">
      <li><a href="#sql-tip-1">Why SELECT * Hurts Performance</a></li>
      <li><a href="#sql-tip-2">Hidden Effects of ORDER BY on Views</a></li>
      <li><a href="#sql-tip-3">JOIN vs WHERE -- What Goes Where and Why</a></li>
    </ul>

    <h4 style="margin-bottom: 0.5rem; margin-top: 1.5rem; color: #374151;">Database Tips</h4>
    <ul style="margin-top: 0.3rem;">
      <li><a href="#db-tip-1">Choosing the Right Data Types</a></li>
    </ul>

    <h4 style="margin-bottom: 0.5rem; margin-top: 1.5rem; color: #374151;">Data Modeling Tips</h4>
    <ul style="margin-top: 0.3rem;">
      <li><a href="#dm-tip-1">Conceptual, Logical, and Physical Models</a></li>
    </ul>

  </aside>

  <!-- MAIN CONTENT -->
  <div style="flex: 1;">

    <section>
      <h2>Welcome</h2>
      <p>
        Learning SQL and understanding how databases really work becomes much easier when concepts are explained clearly
        and in the right order. This section is where I share short, practical insights on SQL, databases, and data
        modeling — the same principles I use when tutoring students one-on-one.
      </p>

      <p>
        Each tip focuses on one idea at a time. Some are beginner-friendly fundamentals, others explore intermediate
        techniques, and some dive into advanced reasoning used in real-world systems. The goal is always the same:
        to help you build clarity, structure, and confidence in how you think about data.
      </p>

      <p>Here are a few example topics you’ll find here:</p>

      <ul>
        <li>Why <code>SELECT *</code> hurts performance more than you think</li>
        <li>INNER vs LEFT JOIN — when each one makes sense</li>
        <li>How to translate real-world rules into tables</li>
        <li>Why normalization reduces anomalies in your data</li>
        <li>Choosing between natural and surrogate keys</li>
      </ul>

      <p>
        New tips are added regularly. Check back often as you continue building your SQL, database, and data modeling skills.
      </p>
    </section>

    <!-- SQL TIP #1 -->
    <section id="sql-tip-1">
      <h2>SQL Tip #1: Why SELECT * Hurts Performance More Than You Think</h2>

      <p>Ever wonder why a query feels slow even when the table isn’t that big? A common culprit is <code>SELECT *</code>. It looks harmless, but it quietly creates several performance problems.</p>

      <h3>What’s really happening when you use SELECT *:</h3>
      <ul>
        <li>You return every column from every table in the query — even ones you don’t need.</li>
        <li>More data means more I/O, more memory use, and more work for the database engine.</li>
        <li>Wide datatypes (JSON, XML, VARCHAR(MAX), BLOB) make the slowdown even worse.</li>
        <li>The optimizer may be unable to use covering indexes, forcing extra lookups.</li>
      </ul>

      <h3>A simple rule of thumb:</h3>
      <p><strong>Only select the columns you actually need.</strong></p>

      <h3>Quick example:</h3>
      <p><strong>Instead of:</strong><br>
      <code>SELECT * FROM Orders</code></p>

      <p><strong>Try:</strong><br>
      <code>SELECT OrderID, OrderDate, TotalAmount FROM Orders</code></p>

      <div style="margin-top: 2rem; border-top: 1px solid #e5e7eb; padding-top: 1rem;">
        <a href="#db-tip-1">Next Tip →</a>
      </div>
    </section>

    <!-- SQL TIP #2 -->
    <section id="sql-tip-2">
    <h2>SQL Tip #2 — The Hidden Effects of Using <code>ORDER BY</code> in Views</h2>

    <p>Ever added an <code>ORDER BY</code> inside a view and expected the results to always come out sorted?</p> 
    <p>It feels intuitive… but most DBMS don’t treat views that way. Relying on <code>ORDER BY</code> inside a view can lead to inconsistent results and assumptions that quietly break as your data or execution plans change.</p>

    <h3>The real issue</h3>
    <p>A view is a logical query, not a stored, pre-sorted dataset. Nothing inside a view is physically materialized, so there’s no ordering to preserve.</p>
    <p>When you query a view, the DBMS expands its definition like a subquery and then optimizes the entire statement as one unit. During this rewrite, the optimizer may:</p>

    <ul>
        <li>remove the <code>ORDER BY</code></li>
        <li>reorder joins</li>
        <li>push filters down</li>
        <li>merge the view into the outer query</li>
    </ul>

    <p>If the <code>ORDER BY</code> inside the view doesn’t affect the logical result, the optimizer is free to ignore it. The logical result is the set of rows returned — not the order in which they appear. Since the <code>ORDER BY</code> inside the view has no effect on which rows are included, it doesn’t influence the logical outcome. As a result, the optimizer can safely drop it during query processing.</p>

    <h3>So why does it look like <code>ORDER BY</code> in a view works?</h3>
    <p>Because sometimes the optimizer chooses a plan that happens to return rows in the order you expect — usually due to:</p>

    <ul>
        <li>an index that matches the view’s <code>ORDER BY</code></li>
        <li>a clustered key aligned with the sort</li>
        <li>a plan that doesn’t need to reorder rows</li>
        <li>small data volumes that don’t trigger alternative strategies</li>
    </ul>

    <p>This creates the illusion that the view is enforcing the sort. But the moment the optimizer chooses a different plan, the order changes. It wasn’t guaranteed — it was coincidence.</p>

    <h3>A simple rule of thumb</h3>
    <p>Treat a view like a subquery — use it to shape the data, and let the outer query handle the sorting.</p>

    <h3>Quick example</h3>
    <p>You create a view with an <code>ORDER BY</code>, then run:</p>

    <pre><code>SELECT * FROM vwStudents;
</code></pre>

    <p>Even if the view sorts by <code>Name</code>, this query is <strong>not guaranteed</strong> to return sorted results.</p>

    <p>To ensure sorted output from a view, code your logic as:</p>

    <pre><code>SELECT * 
FROM (SELECT * FROM vwStudents) AS x
ORDER BY x.Name;
</code></pre>

    <p>This works — but not because the view had an <code>ORDER BY</code>. It works because the <strong>outer query</strong> controls the final ordering.</p>

    <h3>Final thought</h3>
    <p>If your results seem to “randomly” change order when querying a view, the root cause is often a misplaced assumption that the view’s <code>ORDER BY</code> is being enforced. Keep sorting in the outer query where it belongs.</p>
</section>

    <!-- SQL TIP #3 -->
<section id="sql-tip-3">
  <h2>SQL Tip #3: JOIN vs WHERE — What Goes Where, and Why It Matters</h2>

  <p>SQL won’t stop you from misusing <code>ON</code> and <code>WHERE</code> — it’ll just give you unpredictable results when you least expect them.</p>
  <p>When writing joins, it’s easy to mix up what belongs in the <code>ON</code> clause and what belongs in the <code>WHERE</code> clause.</p>
  <p>A simple rule keeps everything clean:</p>

  <h3>ON vs WHERE — The Core Idea</h3>
  <ul>
    <li><strong>(join) ON:</strong> defines how tables relate (PK/FK)</li>
    <li><strong>WHERE:</strong> defines which rows survive after the join</li>
  </ul>

  <p>Think of it this way:</p>
  <ul>
    <li><strong>ON = relationship logic</strong></li>
    <li><strong>WHERE = filtering logic</strong></li>
  </ul>

  <p>This mental model prevents subtle bugs — especially with outer joins.</p>

  <h3>INNER JOIN: Filter in ON vs Filter in WHERE</h3>
  <p>For INNER JOINs, these two patterns behave the same:</p>

  <p><strong>Filter inside the JOIN</strong></p>
  <pre><code>JOIN Orders o ON c.CustomerID = o.CustomerID
AND c.City = o.City</code></pre>

  <p><strong>Filter inside the WHERE</strong></p>
  <pre><code>JOIN Orders o ON c.CustomerID = o.CustomerID
WHERE c.City = o.City</code></pre>

  <p>
    Both return the same rows (NULLs aside) because INNER JOIN only keeps rows that satisfy both conditions.
    This is why INNER JOIN isn’t ideal for showing the ON vs WHERE difference.
  </p>

  <h3>LEFT/RIGHT/FULL JOIN: Where the Difference Actually Matters</h3>
  <p>Outer joins preserve unmatched rows — and that’s where ON vs WHERE diverge.</p>

  <h3>LEFT JOIN + AND (Filtering affects row matching)</h3>
  <pre><code>LEFT JOIN Orders o ON c.CustomerID = o.CustomerID
AND c.City = o.City</code></pre>

  <ul>
    <li>The ON clause defines the row-matching rule</li>
    <li>If the city comparison fails (including NULL), the row simply doesn’t match</li>
    <li>But because it’s a LEFT JOIN, the left row still returns with NULLs on the right</li>
  </ul>

  <p>This preserves the core LEFT JOIN behavior: return all rows from the left table.</p>

  <h3>LEFT JOIN + WHERE (Filtering affects row survival)</h3>
  <pre><code>LEFT JOIN Orders o ON c.CustomerID = o.CustomerID
WHERE c.City = o.City</code></pre>

  <ul>
    <li>The LEFT JOIN first returns matched + unmatched rows</li>
    <li>The WHERE clause filters afterward</li>
    <li>Unmatched rows fail the comparison and are removed</li>
  </ul>

  <p>This effectively turns the LEFT JOIN into an INNER JOIN.</p>

  <h3>Closing Thought</h3>
  <p>
    Use <code>ON</code> to describe how tables connect.<br>
    Use <code>WHERE</code> to filter the final result set.
  </p>

  <p>
    For INNER JOINs, both approaches look the same.<br>
    For LEFT, RIGHT, and FULL OUTER JOINs, they behave very differently — and understanding that distinction is essential for predictable SQL.
  </p>

  <h3>One Last Best Practice</h3>
  <p><strong>Avoid using WHERE to join tables.</strong><br>
     Always join using <code>JOIN … ON</code> — it keeps your intent clear and your outer joins behaving as expected.
  </p>

  <div style="margin-top: 2rem; border-top: 1px solid #e5e7eb; padding-top: 1rem;">
    <a href="#sql-tip-1">Back to Top ?</a>
  </div>
</section>
    
    <!-- DATABASE TIP #1 -->
    <section id="db-tip-1">
      <h2>Database Tip #1: Why Choosing the Right Data Types Matters</h2>

      <p>This is a classic example of why datatypes matter more than most people think.<br>
         Oversized or inconsistent data types often cause unnecessary storage and slower reads.</p>

      <h3>What goes wrong when using the wrong data type:</h3>
      <ul>
        <li><strong>Poor integrity:</strong> Storing dates as VARCHAR allows inconsistent formats like 1/10/2025, 2025/10/1, or January 10, 2025.</li>
        <li><strong>Invalid values:</strong> A column meant for ages defined as VARCHAR could accept values like <em>‘twenty’</em>, <em>‘20’</em> or <em>‘999’</em>.</li>
        <li><strong>Slower queries:</strong> Comparing '123' (stored as text) to a number forces the database to convert types, possibly blocking index use.</li>
        <li><strong>Inefficient sorting:</strong> Sorting '10', '2', '100' as strings gives incorrect order compared to numeric sorting.</li>
        <li><strong>Wasted storage:</strong> Using <code>CHAR(50)</code> for a 2-digit code inflates row size and reduces page density; use VARCHAR instead.</li>
        <li><strong>Weaker validation:</strong> A VARCHAR column meant for prices can’t prevent entries like <em>‘free’</em> or <em>‘ten dollars’</em>.</li>
      </ul>

      <h3>When using the wrong data length:</h3>
      <p>For example, storing a person’s age as <code>NUMBER(2)</code> is sufficient.  However, specifying a length of 5 instead can lead to:</p>

      <ul>
        <li>Extra storage for a wider numeric definition.</li>
        <li>Larger index entries, which can slow index scans and lookups.</li>
        <li>Reduced block/page density because fewer rows fit into each data block.</li>
        <li>More work for the engine to handle higher precision numeric type than needed.</li>
        <li>Increased memory and cache usage when moving and comparing the wider value.</li>
      </ul>

      <h3>Two simple rules of thumb:</h3>
      <ol>
        <li><strong>Match the data type to the nature of the data.</strong></li>
        For example:
          CHAR/VARCHAR for alphanumeric text.<br>
          INT/NUMBER/DECIMAL, etc. for numeric values.<br>
          DATE/DATETIME for dates and timestamps.
        <li><strong>Specify a maximum length that makes sense.</strong></li>
          For example, using NUMBER(10) for a person’s age is excessive.<br>
          Age will never exceed three digits (and realistically, two).
      </ol>

      <div style="margin-top: 2rem; border-top: 1px solid #e5e7eb; padding-top: 1rem;">
        <a href="#sql-tip-1">← Previous Tip</a>
      </div>
    </section>

<!-- DATA MODELING TIP #1 -->
<section id="dm-tip-1">
  <h2>Data Modeling Tip #1: Conceptual, Logical, and Physical Models</h2>

  <p>
    A solid database doesn't begin with tables — it begins with understanding the business. 
    Data modeling gives you a structured path from idea to schema, moving through three layers:
  </p>

  <ul>
    <li>Conceptual</li>
    <li>Logical</li>
    <li>Physical</li>
  </ul>

  <p>
    Each layer answers a different question — what the business needs, how the data fits together, 
    and how it will be implemented; adding more detail and precision at each step.
  </p>

  <p>
    Data modeling isn't just documentation — it's how you prevent rework, miscommunication, and 
    inconsistent data structures. When these layers are skipped or blurred, teams end up with 
    mismatched assumptions, duplicated data, and systems that are hard to maintain.
  </p>

  <h3>Conceptual Model — The Business View</h3>

  <p>
    This is the highest-level model. It captures what the business cares about, without technical detail.
    A conceptual model is like a city map that shows neighborhoods but not street names — it gives 
    orientation without overwhelming detail.
  </p>

  <h4>Focus:</h4>
  <ul>
    <li>Major entities (Customer, Order, Product)</li>
    <li>High-level relationships (Customers place Orders)</li>
    <li>No attributes, no keys, no data types</li>
  </ul>

  <h4>Purpose:</h4>
  <p>
    Align business stakeholders on the core “things” the system must track.  
    Once the business concepts are clear, we can add structure.
  </p>

  <h3>Logical Model — The Structural Blueprint</h3>

  <p>
    This is where the model becomes detailed and structured, but still independent of any specific 
    database platform.
  </p>

  <h4>Focus:</h4>
  <ul>
    <li>Entities and their attributes</li>
    <li>Primary keys and candidate keys</li>
    <li>Relationship cardinalities (1:1, 1‑M, M:N)</li>
    <li>Normalization and business rules</li>
  </ul>

  <p>
    Normalization ensures each fact is stored once, in the right place, reducing redundancy and 
    improving data integrity. The logical model is where these rules take shape.
  </p>

  <h4>Purpose:</h4>
  <p>
    Define how the data fits together logically.
  </p>

  <p>Where entities and attributes fit:</p>
  <ul>
    <li>Entities remain entities</li>
    <li>Attributes are now fully defined</li>
    <li>Still no tables or columns — this is platform‑agnostic</li>
    <li>Keys and relationships are introduced to define identity and structure</li>
  </ul>

  <p>
    At the logical stage, nothing is tied to Oracle, SQL Server, PostgreSQL, MySQL, or any specific DBMS.  
    It’s the “what” and “how,” not the “where.”
  </p>

  <h3>Physical Model — The Database Implementation</h3>

  <p>
    This is the model that becomes the actual database schema.
  </p>

  <h4>Focus:</h4>
  <ul>
    <li>Tables and columns</li>
    <li>Data types</li>
    <li>Indexes, constraints, foreign keys</li>
    <li>Naming conventions (e.g., <code>customer_id</code>, <code>order_id</code>)</li>
    <li>Platform‑specific considerations (SQL Server, PostgreSQL, MySQL, etc.)</li>
  </ul>

  <h4>Purpose:</h4>
  <p>
    Translate the logical design into a working, optimized database.
  </p>

  <p>Where entities and attributes fit:</p>
  <ul>
    <li>Entities become tables</li>
    <li>Attributes become columns</li>
    <li>Relationships become foreign keys</li>
    <li>Keys become PK/FK constraints and indexes</li>
  </ul>

  <p>
    This is the stage where the abstract becomes concrete.  
    The physical model introduces performance considerations: indexing strategies, storage formats, 
    partitioning, and naming conventions that support long‑term maintainability.
  </p>

  <h3>Example Across All Three Layers</h3>

  <h4>Conceptual:</h4>
  <figure>
    <pre>
CUSTOMERS
ORDERS
PRODUCTS
    </pre>
  </figure>
  <p>Entities and relationships only.</p>

  <h4>Logical:</h4>
  <figure>
    <pre>
CUSTOMERS              ORDERS
customer_id (P)        order_id (P)
customer_name          customer_id (F)
customer_contact       order_date
                       order_total

PRODUCTS               ORDER_ITEMS
product_id (P)         order_id (PF)
product_description    order_item_id (P)
product_msrp           product_id (F)
                       quantity
    </pre>
  </figure>
  <p>Entities, attributes, relationships, keys.</p>

  <h4>Physical:</h4>

  <figure>
    <pre>
CUSTOMERS
PK  customer_id        numeric(8)
    customer_name      varchar2(50)
    customer_contact   varchar2(50)
    </pre>
  </figure>

  <table>
    <tr><th colspan="3">ORDERS</th></tr>
    <tr><th>PK</th><th>order_id</th><th>numeric(8)</th></tr>
    <tr><td rowspan="3">FK</td><td>customer_id</td><td>numeric(8)</td></tr>
    <tr><td>order_date</td><td>date</td></tr>
    <tr><td>order_total</td><td>numeric(8,2)</td></tr>
  </table>

  <table>
    <tr><th colspan="3">PRODUCTS</th></tr>
    <tr><th>PK</th><th colspan="2">product_id numeric(8)</th></tr>
    <tr><td></td><td>product_description</td><td>varchar2(100)</td></tr>
    <tr><td></td><td>product_msrp</td><td>numeric(6,2)</td></tr>
  </table>

  <table>
    <tr><th colspan="3">ORDER_ITEMS</th></tr>
    <tr><th rowspan="2">PK/FK</th><th>order_id</th><th>numeric(8)</th></tr>
    <tr><th>order_item_id</th><th>numeric(8)</th></tr>
    <tr><td rowspan="3">FK</td><td>product_id</td><td>numeric(8)</td></tr>
    <tr><td>quantity</td><td>numeric(3)</td></tr>
    <tr><td></td><td></td></tr>
  </table>

  <p>Tables, columns, relationships, keys, datatypes.</p>

  <h3>Final Thoughts</h3>
  <p>
    Conceptual models define the things.<br>
    Logical models define the details.<br>
    Physical models define the implementation.<br>
    Entities become tables.<br>
    Attributes become columns.
  </p>

  <p>
    Get that flow right, and your data model becomes clear, scalable, and easy to maintain.
  </p>

  <h3>Quick Disclaimer</h3>
  <p>
    It's common to hear people refer to entities as “tables” and attributes as “columns” even when discussing 
    conceptual or logical models. It’s everyday shorthand — just be aware of which layer you’re actually working in.
  </p>

  <div style="margin-top: 2rem; border-top: 1px solid #e5e7eb; padding-top: 1rem;">
    <a href="#sql-tip-1">Back to Top →</a>
  </div>
</section>

  </div>
</main>
  
<footer>
  &copy; <span id="year"></span> db.sql.tutor – Database & SQL Tutoring
</footer>

<script>
  document.getElementById('year').textContent = new Date().getFullYear();
</script>

</body>
</html>
